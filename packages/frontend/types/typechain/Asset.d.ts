/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides
} from 'ethers'
import { BytesLike } from '@ethersproject/bytes'
import { Listener, Provider } from '@ethersproject/providers'
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi'
import { TypedEventFilter, TypedEvent, TypedListener } from './commons'

interface AssetInterface extends ethers.utils.Interface {
  functions: {
    'allow(address,uint256)': FunctionFragment
    'allowBatch(address[],uint256)': FunctionFragment
    'balanceOf(address,uint256)': FunctionFragment
    'balanceOfBatch(address[],uint256[])': FunctionFragment
    'batchDivideInto(uint256,uint256[],uint256[])': FunctionFragment
    'create(uint256,bool,bool,uint256)': FunctionFragment
    'createLicence(uint256,address,uint256)': FunctionFragment
    'createRoot(bool,bool,uint256)': FunctionFragment
    'disableToken(uint256)': FunctionFragment
    'disallow(address,uint256)': FunctionFragment
    'disallowBatch(address[],uint256)': FunctionFragment
    'divisionOf(uint256)': FunctionFragment
    'enableToken(uint256)': FunctionFragment
    'getExpiration(uint256)': FunctionFragment
    'getMinStepSize(uint256)': FunctionFragment
    'getParentID(uint256)': FunctionFragment
    'getWeight(uint256)': FunctionFragment
    'isAllowed(uint256,address)': FunctionFragment
    'isApprovedForAll(address,address)': FunctionFragment
    'isDivisible(uint256)': FunctionFragment
    'isLicence(uint256)': FunctionFragment
    'isPublic(uint256)': FunctionFragment
    'joinBack(uint256)': FunctionFragment
    'licenceOf(uint256)': FunctionFragment
    'makeDivisible(uint256)': FunctionFragment
    'makeNotDivisible(uint256)': FunctionFragment
    'makePrivate(uint256)': FunctionFragment
    'makePublic(uint256)': FunctionFragment
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment
    'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment
    'send(address,uint256)': FunctionFragment
    'sendFrom(address,address,uint256)': FunctionFragment
    'setApprovalForAll(address,bool)': FunctionFragment
    'setMinStepSize(uint256,uint256)': FunctionFragment
    'setWeight(uint256,uint256)': FunctionFragment
    'stepDivideInto(uint256,uint256,uint256)': FunctionFragment
    'supportsInterface(bytes4)': FunctionFragment
    'uri(uint256)': FunctionFragment
  }

  encodeFunctionData(
    functionFragment: 'allow',
    values: [string, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'allowBatch',
    values: [string[], BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [string, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [string[], BigNumberish[]]
  ): string
  encodeFunctionData(
    functionFragment: 'batchDivideInto',
    values: [BigNumberish, BigNumberish[], BigNumberish[]]
  ): string
  encodeFunctionData(
    functionFragment: 'create',
    values: [BigNumberish, boolean, boolean, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'createLicence',
    values: [BigNumberish, string, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'createRoot',
    values: [boolean, boolean, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'disableToken',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'disallow',
    values: [string, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'disallowBatch',
    values: [string[], BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'divisionOf',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'enableToken',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'getExpiration',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'getMinStepSize',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'getParentID',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'getWeight',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'isAllowed',
    values: [BigNumberish, string]
  ): string
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [string, string]
  ): string
  encodeFunctionData(
    functionFragment: 'isDivisible',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'isLicence',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'isPublic',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'joinBack',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'licenceOf',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'makeDivisible',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'makeNotDivisible',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'makePrivate',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'makePublic',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'safeBatchTransferFrom',
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string
  encodeFunctionData(
    functionFragment: 'safeTransferFrom',
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string
  encodeFunctionData(
    functionFragment: 'send',
    values: [string, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'sendFrom',
    values: [string, string, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [string, boolean]
  ): string
  encodeFunctionData(
    functionFragment: 'setMinStepSize',
    values: [BigNumberish, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'setWeight',
    values: [BigNumberish, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'stepDivideInto',
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string
  encodeFunctionData(functionFragment: 'uri', values: [BigNumberish]): string

  decodeFunctionResult(functionFragment: 'allow', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'allowBatch', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'balanceOfBatch',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'batchDivideInto',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'create', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'createLicence',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'createRoot', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'disableToken',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'disallow', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'disallowBatch',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'divisionOf', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'enableToken', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'getExpiration',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getMinStepSize',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'getParentID', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getWeight', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'isAllowed', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'isApprovedForAll',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'isDivisible', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'isLicence', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'isPublic', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'joinBack', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'licenceOf', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'makeDivisible',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'makeNotDivisible',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'makePrivate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'makePublic', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'safeBatchTransferFrom',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'send', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'sendFrom', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'setApprovalForAll',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setMinStepSize',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'setWeight', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'stepDivideInto',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'uri', data: BytesLike): Result

  events: {
    'ApprovalForAll(address,address,bool)': EventFragment
    'Divide(uint256[])': EventFragment
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment
    'URI(string,uint256)': EventFragment
    'joinBackEvent(uint256)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Divide'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'joinBackEvent'): EventFragment
}

export class Asset extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this

  listeners(eventName?: string): Array<Listener>
  off(eventName: string, listener: Listener): this
  on(eventName: string, listener: Listener): this
  once(eventName: string, listener: Listener): this
  removeListener(eventName: string, listener: Listener): this
  removeAllListeners(eventName?: string): this

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>

  interface: AssetInterface

  functions: {
    allow(
      _address: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    allowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>

    batchDivideInto(
      _id: BigNumberish,
      listOfNumSizes: BigNumberish[],
      listOfStepSizes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    create(
      _pid: BigNumberish,
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    createLicence(
      _pid: BigNumberish,
      _to: string,
      _expirationDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    createRoot(
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    disableToken(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    disallow(
      _address: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    disallowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    divisionOf(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { divID: BigNumber }>

    enableToken(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    getExpiration(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    getMinStepSize(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { minStepSize: BigNumber }>

    getParentID(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    getWeight(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { weight: BigNumber }>

    isAllowed(
      id: BigNumberish,
      requester: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    isDivisible(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _isDivisible: boolean }>

    isLicence(_id: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>

    isPublic(id: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>

    joinBack(
      _idToJoinBack: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    licenceOf(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    makeDivisible(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    makeNotDivisible(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    makePrivate(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    makePublic(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    send(
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    sendFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setMinStepSize(
      _id: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setWeight(
      _id: BigNumberish,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    stepDivideInto(
      _id: BigNumberish,
      _stepNum: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>
  }

  allow(
    _address: string,
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  allowBatch(
    _addresses: string[],
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>

  batchDivideInto(
    _id: BigNumberish,
    listOfNumSizes: BigNumberish[],
    listOfStepSizes: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  create(
    _pid: BigNumberish,
    _isPublic: boolean,
    _isDivisible: boolean,
    _weight: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  createLicence(
    _pid: BigNumberish,
    _to: string,
    _expirationDate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  createRoot(
    _isPublic: boolean,
    _isDivisible: boolean,
    _weight: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  disableToken(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  disallow(
    _address: string,
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  disallowBatch(
    _addresses: string[],
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  divisionOf(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

  enableToken(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  getExpiration(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  getMinStepSize(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  getParentID(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

  getWeight(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

  isAllowed(
    id: BigNumberish,
    requester: string,
    overrides?: CallOverrides
  ): Promise<boolean>

  isApprovedForAll(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>

  isDivisible(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>

  isLicence(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>

  isPublic(id: BigNumberish, overrides?: CallOverrides): Promise<boolean>

  joinBack(
    _idToJoinBack: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  licenceOf(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

  makeDivisible(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  makeNotDivisible(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  makePrivate(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  makePublic(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  safeBatchTransferFrom(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  safeTransferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  send(
    _to: string,
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  sendFrom(
    _from: string,
    _to: string,
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setApprovalForAll(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setMinStepSize(
    _id: BigNumberish,
    _stepSize: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setWeight(
    _id: BigNumberish,
    _weight: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  stepDivideInto(
    _id: BigNumberish,
    _stepNum: BigNumberish,
    _stepSize: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>

  uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>

  callStatic: {
    allow(
      _address: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    allowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    batchDivideInto(
      _id: BigNumberish,
      listOfNumSizes: BigNumberish[],
      listOfStepSizes: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    create(
      _pid: BigNumberish,
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    createLicence(
      _pid: BigNumberish,
      _to: string,
      _expirationDate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    createRoot(
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    disableToken(_id: BigNumberish, overrides?: CallOverrides): Promise<void>

    disallow(
      _address: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    disallowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    divisionOf(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    enableToken(_id: BigNumberish, overrides?: CallOverrides): Promise<void>

    getExpiration(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getMinStepSize(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getParentID(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getWeight(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    isAllowed(
      id: BigNumberish,
      requester: string,
      overrides?: CallOverrides
    ): Promise<boolean>

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>

    isDivisible(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>

    isLicence(_id: BigNumberish, overrides?: CallOverrides): Promise<boolean>

    isPublic(id: BigNumberish, overrides?: CallOverrides): Promise<boolean>

    joinBack(
      _idToJoinBack: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    licenceOf(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    makeDivisible(_id: BigNumberish, overrides?: CallOverrides): Promise<void>

    makeNotDivisible(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    makePrivate(_id: BigNumberish, overrides?: CallOverrides): Promise<void>

    makePublic(_id: BigNumberish, overrides?: CallOverrides): Promise<void>

    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>

    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>

    send(
      _to: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    sendFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>

    setMinStepSize(
      _id: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    setWeight(
      _id: BigNumberish,
      _weight: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>

    stepDivideInto(
      _id: BigNumberish,
      _stepNum: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>

    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>
  }

  filters: {
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): TypedEventFilter<
      [string, string, boolean],
      { account: string; operator: string; approved: boolean }
    >

    Divide(
      listOfIDs?: null
    ): TypedEventFilter<[BigNumber[]], { listOfIDs: BigNumber[] }>

    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber[], BigNumber[]],
      {
        operator: string
        from: string
        to: string
        ids: BigNumber[]
        values: BigNumber[]
      }
    >

    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, BigNumber],
      {
        operator: string
        from: string
        to: string
        id: BigNumber
        value: BigNumber
      }
    >

    URI(
      value?: null,
      id?: BigNumberish | null
    ): TypedEventFilter<[string, BigNumber], { value: string; id: BigNumber }>

    joinBackEvent(
      _idOfUpdatedAsset?: null
    ): TypedEventFilter<[BigNumber], { _idOfUpdatedAsset: BigNumber }>
  }

  estimateGas: {
    allow(
      _address: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    allowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>

    batchDivideInto(
      _id: BigNumberish,
      listOfNumSizes: BigNumberish[],
      listOfStepSizes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    create(
      _pid: BigNumberish,
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    createLicence(
      _pid: BigNumberish,
      _to: string,
      _expirationDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    createRoot(
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    disableToken(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    disallow(
      _address: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    disallowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    divisionOf(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    enableToken(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    getExpiration(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getMinStepSize(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getParentID(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getWeight(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    isAllowed(
      id: BigNumberish,
      requester: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    isDivisible(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    isLicence(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    isPublic(id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    joinBack(
      _idToJoinBack: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    licenceOf(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    makeDivisible(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    makeNotDivisible(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    makePrivate(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    makePublic(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    send(
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    sendFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setMinStepSize(
      _id: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setWeight(
      _id: BigNumberish,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    stepDivideInto(
      _id: BigNumberish,
      _stepNum: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>
  }

  populateTransaction: {
    allow(
      _address: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    allowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    batchDivideInto(
      _id: BigNumberish,
      listOfNumSizes: BigNumberish[],
      listOfStepSizes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    create(
      _pid: BigNumberish,
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    createLicence(
      _pid: BigNumberish,
      _to: string,
      _expirationDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    createRoot(
      _isPublic: boolean,
      _isDivisible: boolean,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    disableToken(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    disallow(
      _address: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    disallowBatch(
      _addresses: string[],
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    divisionOf(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    enableToken(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    getExpiration(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getMinStepSize(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getParentID(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getWeight(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isAllowed(
      id: BigNumberish,
      requester: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isDivisible(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isLicence(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    isPublic(
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    joinBack(
      _idToJoinBack: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    licenceOf(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    makeDivisible(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    makeNotDivisible(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    makePrivate(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    makePublic(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    send(
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    sendFrom(
      _from: string,
      _to: string,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setMinStepSize(
      _id: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setWeight(
      _id: BigNumberish,
      _weight: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    stepDivideInto(
      _id: BigNumberish,
      _stepNum: BigNumberish,
      _stepSize: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    uri(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>
  }
}
